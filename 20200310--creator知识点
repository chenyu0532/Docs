1. 
    //弧度转为度
      cc.misc.radiansToDegrees(rad);
    // 角度转为弧度
     cc.misc.degreesToRadians(deg);

     clampf ：限定浮点数的最大最小值。
               数值大于 max_inclusive 则返回 max_inclusive。
               数值小于 min_inclusive 则返回 min_inclusive。
               否则返回自身。
               var v1 = cc.misc.clampf(20, 0, 20); // 20;
               var v2 = cc.misc.clampf(-1, 0, 20); //  0;
               var v3 = cc.misc.clampf(10, 0, 20); // 10;
               
     clamp01：限定浮点数的取值范围为 0 ~ 1 之间。
              var v1 = cc.misc.clamp01(20);  // 1;
              var v2 = cc.misc.clamp01(-1);  // 0;
              var v3 = cc.misc.clamp01(0.5); // 0.5;
     
     插值：在from与to之间根据t值比例乘以两者之间的差再加到from上，依次地逼近to的值，但是永远不可能达到to值；
      let from = 200;
      let to = 220;
      let t = 0.5;
      let n = cc.misc.lerp(from, to, t);
      例子：警报灯闪烁
      void Update () {

        if (alermOn == true)
        {
            _light.intensity = Mathf.Lerp(_light.intensity, targetIntensity, Time.deltaTime * intensitySpeed);
            if ((Mathf.Abs(_light.intensity - targetIntensity)) <= 0.05f)//因为线性插值使得fromintensity永远不会与tointensity相等，并且到后来每次变化的    
                 值也会减小
            {//如果达到了这种地步将起始的两个值对调，使灯光渐渐变暗，达到自然的情况
                if (targetIntensity == heighIntensity)
                {//当目标数值为高数值时，需要将它换成低数值
                    targetIntensity = lowIntensity;
                }
                else if (targetIntensity == lowIntensity)//当目标数值是低数值时，将它换成高数值，如此可实现由高到低由低到高的渐变过程
                {
                    targetIntensity = heighIntensity;
                }
            }
        }
      }

      //TODO 物体运动  中断  转向

2.  当在做打飞机等类型的游戏时，因为需要控制飞机的四周最大最小坐标
    可以定义几个变量：minXminY: cc.v2(xxxx,yyyy)
                    maxXmaxY: cc.v2(ccc,ddd)
    想定义成下拉框的选择类型时，需要用到枚举
        let LimitType = cc.Enum({
            // 数字模式
            Number: 0,
            // 节点模式
            Node: 1,
        });
        limitType:LimitType

3.  物体的头部左右转运动
	let hudu = cc.misc.degreesToRadians(this.role.rotation);
	this.role.x += this.speed * Math.sin(hudu);//////sin cos等这些参数是弧度...
	this.role.y += this.speed * Math.cos(hudu);

4. 各种坐标转换

	屏幕坐标系：左上角为原点
	cocos2d-x和openGL坐标系：左下角为原点
	世界坐标系/绝对坐标系：左下角为原点
	
  //后面传的坐标，是相对于你这个节点的父节点下的坐标
	A.parent.convertToWorldSpaceAR(A.position); // A的坐标转换为世界坐标


