
1. 
    //弧度转为度
      cc.misc.radiansToDegrees(rad);
    // 角度转为弧度
     cc.misc.degreesToRadians(deg);

     clampf ：限定浮点数的最大最小值。
               数值大于 max_inclusive 则返回 max_inclusive。
               数值小于 min_inclusive 则返回 min_inclusive。
               否则返回自身。
               var v1 = cc.misc.clampf(20, 0, 20); // 20;
               var v2 = cc.misc.clampf(-1, 0, 20); //  0;
               var v3 = cc.misc.clampf(10, 0, 20); // 10;
               
     clamp01：限定浮点数的取值范围为 0 ~ 1 之间。
              var v1 = cc.misc.clamp01(20);  // 1;
              var v2 = cc.misc.clamp01(-1);  // 0;
              var v3 = cc.misc.clamp01(0.5); // 0.5;
     
     插值：在from与to之间根据t值比例乘以两者之间的差再加到from上，依次地逼近to的值，但是永远不可能达到to值；
      let from = 200;
      let to = 220;
      let t = 0.5;
      let n = cc.misc.lerp(from, to, t);
      例子：警报灯闪烁
      void update () {

        if (alermOn == true)
        {
            _light.intensity = cc.misc.lerp(_light.intensity, targetIntensity, Time.deltaTime * intensitySpeed);
            if ((Mathf.Abs(_light.intensity - targetIntensity)) <= 0.05f)//因为线性插值使得fromintensity永远不会与tointensity相等，并且到后来每次变化的    
                 值也会减小
            {//如果达到了这种地步将起始的两个值对调，使灯光渐渐变暗，达到自然的情况
                if (targetIntensity == heighIntensity)
                {//当目标数值为高数值时，需要将它换成低数值
                    targetIntensity = lowIntensity;
                }
            else if (targetIntensity ===lowIntensity)
            //当目标数值是低数值时，将它换成高数值，如此可实现由高到低由低到高的渐变过程
                {
                    targetIntensity = heighIntensity;
                }
            }
        }
      }

      //物体运动  中断  转向
      let touchpos = event.touch.getLocation();
      this.pos = this.node.convertToNodeSpaceAR(touchpos);
      update(dt) {
        this.sp.x = cc.misc.lerp(this.sp.x, this.pos.x, dt * this.speedConstant);
        this.sp.y = cc.misc.lerp(this.sp.y, this.pos.y, dt * this.speedConstant);
    }


2.  当在做打飞机等类型的游戏时，因为需要控制飞机的四周最大最小坐标
    可以定义几个变量：minXminY: cc.v2(xxxx,yyyy)
                    maxXmaxY: cc.v2(ccc,ddd)
    想定义成下拉框的选择类型时，需要用到枚举
        let LimitType = cc.Enum({
            // 数字模式
            Number: 0,
            // 节点模式
            Node: 1,
        });
        limitType:LimitType

3.  物体的头部左右转运动
	let hudu = cc.misc.degreesToRadians(this.role.rotation);
	this.role.x += this.speed * Math.sin(hudu);//////sin cos等这些参数是弧度...
	this.role.y += this.speed * Math.cos(hudu);

4. destroy()后发生的事情-----
        this.testNode = new cc.Node();
        this.testNode.state = 'default';
        this.node.addChild(this.testNode);
    Node在destroy()后并不会立即发生变化，得等下一帧的时候才有变化

    在当前帧里：node的引用依然存在 (console.log(this.testNode)-->[Object Object])
               它的自定义属性不会消失(console.log(this.testNode.state)--->default)
               console.log(cc.isValid(this.testNode))--->true

    在下一帧里：node的引用依然存在 (console.log(this.testNode)-->[Object Object])
               但是它的自定义属性会消失(console.log(this.testNode.state)--->undefined)
               另外console.log(cc.isValid(this.testNode))--->false

    如果想在当前帧里判断是不是destroy()了，那么要用cc.isValid(this.testNode, true)

5.  (1)// 准确判断数据的类型 boolean object array string等
    function type(o){
        let s  = Object.prototype.toString.call(o);
        return s.slice(s.indexOf(" ") + 1, s.length - 1).toLowerCase();
    }
    (2)//或者用Typeof2库

6. 各种坐标转换

	屏幕坐标系：左上角为原点
	cocos2d-x和openGL坐标系：左下角为原点
	世界坐标系/绝对坐标系：左下角为原点
	
  //后面传的坐标，是相对于你这个节点的父节点下的坐标
	A.parent.convertToWorldSpaceAR(A.position); // A的坐标转换为世界坐标

  A.parent.convertToNodeSpaceAR(touchPos); //将touchPos坐标转换到A的父节点的坐标
    (如果A有子节点B，那么转换的坐标跟B是一个坐标系了)

    // 如果在摄像机下，摄像机的zoomRadio改变了，那么现在的touchPos的点就不是原来zoomRadio=1时候的点了需要用
    //  getScreenToWorldPoint(touchPos, realPos)来转化
  getComponent(cc.Camera).getScreenToWorldPoint 将一个摄像机坐标系下的点转换到世界坐标系下。
  
  getComponent(cc.Camera).getWorldToScreenPoint 将一个世界坐标系下的点转换到摄像机坐标系下。


7. 摇杆：
    //触摸加在了摇杆的背景上
    clampPos (pos) {
        let len = pos.mag();
        if (len > this.maxR) { // 圆的半径
            let k = this.maxR / len;
            pos.x *= k;
            pos.y *= k;
        }
    },
    onTouchMove (e) {
        let pos = this.node.convertToNodeSpaceAR(e.getLocation());
        this.clampPos(pos);
        this.midNode.setPosition(pos.x, pos.y);
        
        let r = Math.atan2(pos.y, pos.x);
        let angle = cc.misc.radiansToDegrees(r);
        this.物体.angle = angle;
        // 触发回调
        this.joyCallBack.emit([pos, angle]); 
    },
    /** 被触发回调 */
    playerMoving (vector, angle) {
        this.vector.x = vector.x;
        this.vector.y = vector.y;
        if (angle) {
            this.node.angle = angle;
        }
    },
    update (dt) {
        const speed = 0.02;
        this.node.x += pos.x * speed;
        this.node.y += pos.y * speed;
    },
    //this.joyCallBack.emit([pos, angle]); 这个是自定义了一个回调，会触发自定义的回调playerMoving
    properties: {
        /** 摇杆移动回调 */
        joyCallBack:  {
            default: [],
            type: cc.Component.EventHandler,
        }
    },

8. angle = rotation - 90;   Math的参数都需要的是弧度
    例如：
        let pos: cc.Vec2 = e.getLocation();
        let x = pos.x - this.shooter.x;
        let y = pos.y - this.shooter.y;
        let radian = Math.atan2(y, x); 
        // 弧度转角度 0 - 2π -> 0 - 360
        let degree = cc.misc.radiansToDegrees(radian);
        console.log(degree);
        // angle 与原版 rotation 差 90
        degree -= 90;
        if (degree < -80 && degree > -180) degree = -80;
        if (degree > 80 || degree <= -180) degree = 80;
        return degree;

9. @property(cc.JsonAsset) levelData: cc.JsonAsset = null; //外部json表格还可以这么用。。。

10. // 改变运动速度 
    let speed = cc.speed(cc.moveTo(10, cc.p(900, 900)), 1);
    this.node.runAction(speed);
    speed.setSpeed(3);
    //或者
    tween.start()之后会出现一个 _finalAction成员。
	修改_finalAction._speedMethod = true。之后可以通过_finalAction._speed 修改速度。

11. 刮刮卡---->见example

12. async.js是一个异步流程控制的库
    应用场景1：切换场景时，如果下一个场景的元素过多，需要加一个loading动。
    	async.parallel([
         function() {
             that.loadingN.active = true;
             that.loadingN.runAction(cc.repeatForever(cc.rotateBy(0.3, 360)));
         },
         function() {
             that.mask.active = true;
             let _armatureDisplay = that.anim.getComponent(dragonBones.ArmatureDisplay);
             that._armature = _armatureDisplay.armature();
             cc.director.preloadScene('game' + common.gameIndex, that.onProgress.bind(that), function(){  
                 if(common.platform === 'toutiao') {
                     common.advRecord.startRecorder();
                 }
                 cc.director.loadScene('game' + common.gameIndex);
            });
         }
     ], function(err, tx, total) {
         console.log(tx[0][0])
     });